# 集合
add(element)向集合添加一个新元素
delete(element)向集合移除一个新元素
has(element) 获取一个元素是否存在这个集合中
clear(element)移除所有元素
size(element)返回集合所包含元素的数量
values(element) 返回一个包含集合中所有元素的数组
```js
const s1 = new Set([1, 2, 3])
const s2 = new Set([3, 4, 5])
// 并集 12345
const bj = new Set([...s1, ...s2])
// 交集 3
const jj = new Set([...s1].filter(x => s2.has(x)))
// 差集 1,2,4,5
const cj = new Set([...[...s1].filter(x => !s2.has(x))])
// 子集 验证一个集合是否是另外一个的子集
const s3 = new Set([1, 2, 3])
const s4 = new Set([1, 2, 3, 4, 5])
const isZj = [...s3].every(e => s4.has(e))
console.log(isZj)
```
# 字典结构
存储健值对结构 map

set(key,value)
remove(key)
hasKey(key)
get(key)
clear()
size()
isEmpty()
keys()
values()
keyValues()
forEach(callbackFn)

字典常见操作
1.合并字典
```js
const m1 = new Map([
  ["a", 1],
  ["b", 2],
])
const m2 = new Map([
  ["c", 10],
  ["b", 20],
])
new map = ([...m1, ...m2])
```
2.过滤字典

3.转换字典键值

# 树结构
- 节点：是树的基本单位
- 根节点：是树的顶端节点
- 父节点：一个节点的上一级节点
- 子节点：一个节点派生出来的节点（只计算下一层）
- 兄弟节点：具备相同父节点的节点互称为兄弟节点
- 叶子节点：它没有子节点的节点
- 深度：树总共有多少层
- 度：一个节点的子节点的个数

## 二叉树
1.满二叉树


**特殊用途树**

- 堆(Heap)：一种完全二叉树，满足堆性质（最大堆/最小堆）

- 线段树(Segment Tree)：每个节点代表一个区间，支持区间查询与更新。常用于动态范围统计，例如区间最值、区间和。

- 哈夫曼树(Huffman Tree)：  构造带权路径最短的二叉树，用于无损数据压缩。常用于 zip 压缩、jpeg 编码。

- 并查集(Union-Find)：  森林表示集合，支持合并与查找操作。常用于连通性问题，例如社交网络好友关系。

- KD树(K-Dimensional Tree)：二叉树，交替按不同维度划分空间。常用于多维数据近邻搜索，例如地理坐标查询的场景。



**其他变种**

- 二叉线索树(Threaded Binary Tree)：  利用空指针记录前驱/后继，加速遍历（中序、先序、后序）。

- 后缀树(Suffix Tree)：压缩字典树，存储字符串所有后缀。常用于模式匹配、生物信息学中 DNA序列分析等场景。

- 决策树(Decision Tree)：机器学习中的分类与回归模型，通过树结构划分特征空间。

**寻找**
- 寻找父节点：`Math.floor((当前节点的下标 - 1) / 2)`，例如：

  | 子节点 | 父节点 |
  | :----: | :----: |
  |   1    |   0    |
  |   2    |   0    |
  |   3    |   1    |
  |   4    |   1    |

- 寻找左分支节点：`当前节点下标 * 2 + 1`，例如：

  | 父节点 | 左分支节点 |
  | :----: | :--------: |
  |   0    |     1      |
  |   1    |     3      |
  |   2    |     5      |

- 寻找右分支节点：`当前节点下标 * 2 + 2`，例如：

  | 父节点 | 左分支节点 |
  | :----: | :--------: |
  |   0    |     2      |
  |   1    |     4      |
  |   2    |     6      |



**完全二叉树遍历**

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-02-26-012002.png" alt="image-20250226092001455" style="zoom:40%;" />

```js
class TreeNode {
  constructor(value) {
    this.value = value; // 节点的值
    this.left = null; // 左子树
    this.right = null; // 右子树
  }
}

// 构建上面的完全二叉树
const root = new TreeNode("A");
root.left = new TreeNode("B");
root.right = new TreeNode("C");
root.left.left = new TreeNode("D");
root.left.right = new TreeNode("E");
root.left.left.left = new TreeNode("H");
root.left.left.right = new TreeNode("I");
root.left.right.left = new TreeNode("J");
root.left.right.right = new TreeNode("K");
root.right.left = new TreeNode("F");
root.right.right = new TreeNode("G");
root.right.left.left = new TreeNode("L");
root.right.left.right = new TreeNode("M");
root.right.right.left = new TreeNode("N");
root.right.right.right = new TreeNode("O");
```

1. 前序遍历

   ```
   根节点 --> 左子树 --> 右子树
   ```

   遍历出来的顺序如下：

   ```
   A -> B -> D -> H -> I -> E -> J -> K -> C -> F -> L -> M -> G -> N -> O
   ```

   ```js
   function preOrder(root){
     if(root === null) return;
     
     // 访问根节点
     console.log(root.value);
     
     // 遍历左子树
     preOrder(root.left);
     
     // 遍历右子树
     preOrder(root.right);
   }
   ```

   

2. 中序遍历

   ```
   左子树 --> 根节点 --> 右子树
   ```

   中序遍历的具体顺序可以看节点投影，投影出来的线性顺序就是遍历出来的顺序

   <img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-02-26-013652.png" alt="image-20250226093651508" style="zoom:40%;" />

   ```
   H -> D -> I -> B -> J -> E -> K -> A -> L -> F -> M -> C -> N -> G -> O
   ```

   ```js
   function inOrder(root){
     if(root === null) return;
     
     // 遍历左子树
     inOrder(root.left);
     
      // 访问根节点
     console.log(root.value);
     
     // 遍历右子树
     inOrder(root.right);
   }
   ```

   

3. 后序遍历

   ```
   左子树 --> 右子树 --> 根节点
   ```

   ```
   H -> I -> D -> J -> K -> E -> B -> L -> M -> F -> N -> O -> G -> C -> A
   ```

   ```js
   function postOrder(root){
     if(root === null) return;
     
     // 遍历左子树
     postOrder(root.left);
     
     // 遍历右子树
     postOrder(root.right);
     
     // 访问根节点
     console.log(root.value);
   }
   ```

## 二叉树深度优先搜索

所谓深度优先搜索，顾名思义，就是先往下找，直到不能再往下了，再切换到平层的节点，切换到平层的节点后，继续往下进行搜索。

前序遍历，遍历的顺序为根节点 -> 左子树 -> 右子树

<img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2025-02-26-012002.png" alt="image-20250226092001455" style="zoom:40%;" />

前序遍历出来的顺序为：

```js
A -> B -> D -> H -> I -> E -> J -> K -> C -> F -> L -> M -> G -> N -> O
```

深度优先搜索（Depth-First-Search，简称 DFS）也是按照这样的顺序。
和前序排序一样
```js
class TreeNode(val){
    constructor(value){
        this.value=value
        this.left=null
        this.right=null
    }
}
// 初始化节点
// ......

function depthFirstSearch(root,target){
    if(root===null) return false
    if(root.value===target){
        return true
    }
   const leftResult= depthFirstSearch(root.left,target)
   const rightResult= depthFirstSearch(root.right,target)
   return leftResult||rightResult

}
depthFirstSearch(root,'J')

```
## 二叉树广度优先搜索
```js
function levelSearch(root, target) {
  if (root === null) return null
  if (root.value === target) return true
  const queue = [] //用于存储每一层的节点
  queue.push(root)
  while (queue.length > 0) {
    const node = queue.shift()
    if (node.value === target) {
      return true
    }
    if (node.left !== null) {
      queue.push(node.left)
    }
    if (node.right !== null) {
      queue.push(node.right)
    }
  }
  return false

}
```
比较完全相等
```js

function compareTree(tree1, tree2) {
  if (tree1 === tree2) return true
  if (tree1 == null || tree2 !== null) return false

  if (tree1.value !== !tree2.value) {
    return false
  }

  const lefresult = compareTree(tree1.left, tree2.left)
  const rightsult = compareTree(tree1.right, tree2.right)
  return lefresult && rightsult

}

```